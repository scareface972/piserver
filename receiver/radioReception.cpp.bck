#include <wiringPi.h>
#include <iostream>
#include <stdio.h>
#include <sys/time.h>
#include <time.h>
#include <stdlib.h>
#include <sstream>

using namespace std;

//initialisation du pin de reception
int pin;

//Fonction de passage du programme en temps réel (car la reception se joue a la micro seconde près)
void scheduler_realtime() {
	struct sched_param p;
	p.__sched_priority = sched_get_priority_max(SCHED_RR);
	if( sched_setscheduler( 0, SCHED_RR, &p ) == -1 ) {
		perror("Failed to switch to realtime scheduler.");
	}
}

//Fonction de remise du programme en temps standard
void scheduler_standard() {
	struct sched_param p;
	p.__sched_priority = 0;
	if( sched_setscheduler( 0, SCHED_OTHER, &p ) == -1 ) {
		perror("Failed to switch to normal scheduler.");
	}
}

//Fonction de log
void log(string a) {
	//Décommenter pour avoir les logs
	cout << a << endl;
}

//Fonction de conversion long vers string
string longToString(long mylong) {
    string mystring;
    stringstream mystream;
    mystream << mylong;
    return mystream.str();
}

//Fonction de conversion int vers string
string intToString(int myint) {
    string mystring;
    stringstream mystream;
    mystream << myint;
    return mystream.str();
}

//Recuperation du temp (en micro secondes) d'une pulsation
int pulseIn(int pin, int level, int timeout) {
   struct timeval tn, t0, t1;
   long micros;
   gettimeofday(&t0, NULL);
   micros = 0;
   while (digitalRead(pin) != level) {
      gettimeofday(&tn, NULL);
      if (tn.tv_sec > t0.tv_sec) micros = 1000000L; else micros = 0;
      micros += (tn.tv_usec - t0.tv_usec);
      if (micros > timeout) return 0;
   }
   gettimeofday(&t1, NULL);
   while (digitalRead(pin) == level) {
      gettimeofday(&tn, NULL);
      if (tn.tv_sec > t0.tv_sec) micros = 1000000L; else micros = 0;
      micros = micros + (tn.tv_usec - t0.tv_usec);
      if (micros > timeout) return 0;
   }
   if (tn.tv_sec > t1.tv_sec) micros = 1000000L; else micros = 0;
   micros = micros + (tn.tv_usec - t1.tv_usec);
   return micros;
}

//Programme principal
int main (int argc, char** argv) {	
	//on récupere l'argument 1, qui est le numéro de Pin GPIO auquel est connecté le recepteur radio
	pin = atoi(argv[1]);
	//Si on ne trouve pas la librairie wiringPI, on arrête l'execution
    if(wiringPiSetup() == -1) {
        log("Error: Librairie Wiring PI introuvable, veuillez lier cette librairie...");
        return -1;
    }
    pinMode(pin, INPUT);
	//log("Pin GPIO configure en entree");
    //log("Attente d'un signal du transmetteur ...");
	
	scheduler_realtime();

	//On boucle pour ecouter les signaux
	for(;;) {
    	int i = 0;
		unsigned long t = 0;
	    //avant dernier byte reçu
		int prevBit = 0;
	    //dernier byte reçu
		int bit = 0;
		//mise a zero de l'idenfiant télécommande
	    unsigned long sender = 0;
		//mise a zero du groupe
	    bool group=false;
		//mise a zero de l'etat on/off
	    bool on =false;
		//mise a zero de l'idenfiant de la rangée de bouton
	    unsigned long recipient = 0;
		string command = ""; //path+" ";
		string seq = "";
		//Verrou 1
		do {
			t = pulseIn(pin, LOW, 1000000);
			//log(longToString(t));
		} while(t < 2400 || t > 2800);
		//log("Verrou 1 detecte");
		// données
		//int lowMin = 0, lowMax = 0;
		//int hightMin = 0, hightMax = 0;
		while(i < 64) {
			t = pulseIn(pin, LOW, 1000000);
			/*if ((t > 300 && t < 360) || (t > 1200 && t < 1500)) {
				cout << "i = " << i << endl;
				cout << "t = " << t << endl;
			}*/
			//Définition du bit (0 ou 1)
	        if(t > 300 && t < 360) {
	        	bit = 0;
	        	//if (lowMin == 0 || t < lowMin) lowMin = t;
	        	//if (lowMax == 0 || t > lowMax) lowMax = t;
			} else if(t > 1200 && t < 1500) {
				bit = 1;
	        	//if (hightMin == 0 || t < hightMin) hightMin = t;
	        	//if (hightMax == 0 || t > hightMax) hightMax = t;
			}
			else {
				i = 0;
				break;
			}
			if (i % 2 == 1) {
				//log("prevbit " + intToString(prevBit) + ", bit " + intToString(bit));
				if((prevBit ^ bit) == 0) {
					// doit être 01 ou 10,,pas 00 ou 11 sinon ou coupe la detection, c'est un parasite
					//log("parasite détécté");
					i = 0;
					break;
				}
				if(i < 53) {
					// les 26 premiers (0-25) bits sont l'identifiants de la télécommande
					sender <<= 1;
					sender |= prevBit;
				} else if(i == 53) {
					// le 26em bit est le bit de groupe
					group = prevBit;
				} else if(i == 55) {
					// le 27em bit est le bit d'etat (on/off)
					on = prevBit;
				} else {
					// les 4 derniers bits (28-32) sont l'identifiant de la rangée de bouton
					recipient <<= 1;
					recipient |= prevBit;
				}
			}
			seq.append(intToString(bit));
			prevBit = bit;
			++i;
		}
		
		//Si les données ont bien été détéctées
	    if (i>0) {
	    	/*cout << "LOW" << endl;
	    	cout << " - min = " << lowMin << endl;
	    	cout << " - max = " << lowMax << endl;
	    	cout << "HIGHT" << endl;
	    	cout << " - min = " << hightMin << endl;
	    	cout << " - max = " << hightMax << endl;
			log(seq);*/
			//log("------------------------------");
			//log("Donnees detectees");
			command.append(longToString(sender));
			//if(group) command.append(" on");
			//else command.append(" off");
			if(on) command.append(" on");
			else command.append(" off");
			command.append(" "+longToString(recipient));
			log(command.c_str());
    		delay(500);
    		//log("restart listening");
		}
		delay(1);
    }
    scheduler_standard();
}

